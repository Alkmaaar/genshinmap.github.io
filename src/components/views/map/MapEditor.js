/**
 * Provides the core component which displays the map tiles,
 * as well as powers the map editing functionality.
 */

import _ from 'lodash';
import React from 'react';
import { AttributionControl, MapContainer, TileLayer } from 'react-leaflet';
import ReactLeafletEditable from 'react-leaflet-editable';
import { connect } from 'react-redux';

import { useImageExtension } from '~/components/interface/Image';
import EditorControls from '~/components/views/map/EditorControls';
import {
  editorMarkerHighlight,
  lineProperties,
  lineTextProperties,
} from '~/components/views/map/LayerConstants';
import MapPositionHandler from '~/components/views/map/MapPositionHandler';
import {
  DEFAULT_ZOOM,
  MAP_BOUNDS,
  MAP_CENTER,
  MAXIMUM_ZOOM,
  MAXIMUM_NATIVE_ZOOM,
  MINIMUM_ZOOM,
  TILE_URL,
} from '~/components/preferences/DefaultPreferences';
import { appendElement, setElementProperty } from '~/redux/ducks/editor';

// A link back to the main repository.
const ATTRIBUTION =
  "<a href='https://github.com/GenshinMap/genshinmap.github.io' rel='noreferrer' target='_blank'><span class='nf nf-fa-github' style='margin-right: 0.5em;'></span>Directions and Feedback</a>";

/**
 * A wrapper which handles editing events.
 * Much of the complexity here comes from the fact we aren't editing the map,
 * we are editing a GeoJSON representation of it.
 *
 * Thus, each element creation must be 'cancelled',
 * then replaced with addition to the GeoJSON data.
 */
// Note: The dispatchers generated by mapDispatchToProps
// shadow their associated action generators.
/* eslint-disable no-shadow */
const _MapEditor = ({
  editRef,
  children,

  appendMarker,
  appendRoute,
  moveMarker,
  moveRoute,
}) => {
  // A separate state must be used because the type of currentEditable can't be determined
  // just by looking at it.
  const [editorState, setEditorState] = React.useState('none');
  const [currentEditable, setCurrentEditable] = React.useState(null);

  const startEditorMarker = () => {
    setEditorState('createMarker');
    const editable = editRef.current.startMarker(null, {
      icon: editorMarkerHighlight,
    });
    setCurrentEditable(editable);
  };

  const startEditorRoute = () => {
    setEditorState('createRoute');
    const editable = editRef.current.startPolyline(null, lineProperties);
    editable.setText('  â–º  ', lineTextProperties);
    setCurrentEditable(editable);
  };

  const placeMarker = (editable) => {
    const { _latlng: latlng } = editable;

    // Note this is not reversed because it corresponds to direct map coordinates.
    const latlngFormatted = [latlng?.lat, latlng?.lng];

    const newMarker = {
      geometry: { type: 'Point', coordinates: latlngFormatted },
      type: 'Feature',
      properties: { popupTitle: { en: '' }, popupContent: { en: '' }, popupMedia: '' },
    };

    appendMarker(newMarker);
    setEditorState('none');
    setCurrentEditable(null);
  };

  const placeRoute = (editable) => {
    const { _latlngs: latlngs } = editable;
    // Note this is not reversed because it corresponds to direct map coordinates.
    const latlngsFormatted = latlngs.map((latlng) => [latlng?.lat, latlng?.lng]);

    const newRoute = {
      geometry: { type: 'LineString', coordinates: latlngsFormatted },
      type: 'Feature',
      properties: { popupTitle: '', popupContent: '', popupMedia: '' },
    };
    appendRoute(newRoute);
    setEditorState('none');
    setCurrentEditable(null);
  };

  const onDragStart = (event) => {
    // Called when starting to drag a marker.

    const isMarker = event.layer.feature.geometry.type === 'Point';
    // const isRouteVertex = event.layer.feature.geometry.type === "LineMarker";

    if (isMarker) {
      setCurrentEditable(event.layer);
      setEditorState('dragMarker');
      // return;
    }
  };

  const onDragEnd = (event) => {
    // If the current mode is 'dragMarker', call our override function,
    // and cancel the event that would occur.

    if (editorState === 'dragMarker') {
      const marker = event.layer.feature;

      // eslint-disable-next-line no-underscore-dangle
      const { _latlng: latlng } = event.layer;

      const newCoords = [latlng.lat, latlng.lng];

      moveMarker(marker, newCoords);
      setEditorState('none');
      setCurrentEditable(null);
    }
  };

  const onVertexMarkerDragStart = (event) => {
    const isRoute = event.layer.feature.geometry.type === 'LineString';
    // const isRouteVertex = event.layer.feature.geometry.type === "LineMarker";
    if (isRoute) {
      setCurrentEditable(event.layer);
      setEditorState('dragRoute');
      // return;
    }
  };

  const onVertexMarkerDragEnd = (event) => {
    // If the current mode is 'dragMarker', call our override function,
    // and cancel the event that would occur.

    if (editorState === 'dragRoute') {
      const route = event.layer.feature;
      const newRouteLatLngs = event.vertex.latlngs.map((vertex) => [vertex.lat, vertex.lng]);

      moveRoute(route, newRouteLatLngs);
      setEditorState('none');
      setCurrentEditable(null);
    }
  };

  const onDrawingCommit = (event, map) => {
    if (editorState === 'createRoute') {
      map.removeLayer(currentEditable);
      placeRoute(currentEditable);
      return;
    }

    if (editorState === 'createMarker') {
      map.removeLayer(currentEditable);
      placeMarker(currentEditable);
      // return;
    }
  };

  // Check for WebP support.
  const ext = useImageExtension(true);

  // Wait until we get confirmation of WebP support.
  if (ext == null) return null;

  const tileUrl = TILE_URL.replace('{ext}', ext);

  return (
    <ReactLeafletEditable
      ref={editRef}
      onDragStart={onDragStart}
      onDragEnd={onDragEnd}
      onVertexMarkerDragStart={onVertexMarkerDragStart}
      onVertexMarkerDragEnd={onVertexMarkerDragEnd}
      onDrawingCommit={onDrawingCommit}
    >
      <MapContainer
        maxBounds={MAP_BOUNDS}
        center={MAP_CENTER}
        zoom={DEFAULT_ZOOM}
        zoomDelta={0.5}
        editable
        zoomSnap={0.5}
        maxZoom={MAXIMUM_ZOOM}
        minZoom={MINIMUM_ZOOM}
        attributionControl={false} // Override the Leaflet attribution with our own AttributionControl.
        zoomControl={false}
      >
        {/* Handles events related to the map position. */}
        <MapPositionHandler />
        {/* Controls the actual map image. */}
        <TileLayer
          url={tileUrl}
          noWrap
          bounds={MAP_BOUNDS}
          errorTileUrl={`tiles/blank.${ext}`}
          maxZoom={MAXIMUM_ZOOM}
          minZoom={MINIMUM_ZOOM}
          maxNativeZoom={MAXIMUM_NATIVE_ZOOM}
          minNativeZoom={MINIMUM_ZOOM}
        />
        {/* Controls the attribution link in the bottom left corner. */}
        <AttributionControl prefix={ATTRIBUTION} position="bottomleft" />
        <EditorControls startEditorMarker={startEditorMarker} startEditorRoute={startEditorRoute} />

        {children}
      </MapContainer>
    </ReactLeafletEditable>
  );
};

const mapStateToProps = (_state) => ({});
const mapDispatchToProps = (dispatch) => ({
  appendMarker: (data) => dispatch(appendElement(data)),
  appendRoute: (data) => dispatch(appendElement(data)),
  moveMarker: (marker, newCoords) =>
    dispatch(setElementProperty(marker, 'geometry.coordinates', newCoords)),
  moveRoute: (route, newCoordsList) =>
    dispatch(setElementProperty(route, 'geometry.coordinates', newCoordsList)),
});
const MapEditorConnected = connect(mapStateToProps, mapDispatchToProps)(_MapEditor);
const MapEditor = React.forwardRef((props, ref) => <MapEditorConnected {...props} editRef={ref} />);

export default MapEditor;
